import subprocess
import time
import logging
import sys
import re

# Configure logging
logging.basicConfig(
    format='%(asctime)s %(levelname)-8s %(message)s',
    level=logging.INFO,
    datefmt='%Y-%m-%d %H:%M:%S',
)

COMPOSE_FILE = "docker-compose.yaml" # Use the main compose file generated by make up

def run_command(cmd, check=True):
    logging.info(f"Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True)
    if check and result.returncode != 0:
        logging.error(f"Command failed: {result.stderr}")
        raise subprocess.CalledProcessError(result.returncode, cmd, result.stdout, result.stderr)
    return result

def get_logs(container):
    cmd = ["docker", "logs", container]
    result = run_command(cmd, check=False)
    return result.stdout + result.stderr

def wait_for_log(container, pattern, timeout=30):
    logging.info(f"Waiting for pattern '{pattern}' in {container} logs...")
    start = time.time()
    while time.time() - start < timeout:
        logs = get_logs(container)
        if re.search(pattern, logs):
            logging.info(f"Found pattern '{pattern}' in {container}!")
            return True
        time.sleep(1)
    logging.error(f"Timeout waiting for '{pattern}' in {container}")
    return False

def main():
    try:
        # 1. Start Cluster (Assuming make up has been run or running it here)
        logging.info("Starting system...")
        # We use make up to generate the compose file and start everything
        run_command(["make", "up"], check=False) 
        
        # Wait for system to stabilize
        logging.info("Waiting for system to stabilize...")
        time.sleep(15)

        # 2. Test Case 1: Server Failure -> FORCE_END
        logging.info("Testing Server Failure -> FORCE_END")
        logging.info("Killing Server...")
        run_command(["docker", "kill", "server"])
        
        # Verify Leader detects it
        if not wait_for_log("monitor_1", "Server died! Broadcasting FORCE_END...", timeout=60):
             # Try other monitors if monitor_1 is not leader
             if not wait_for_log("monitor_2", "Server died! Broadcasting FORCE_END...", timeout=10):
                 if not wait_for_log("monitor_3", "Server died! Broadcasting FORCE_END...", timeout=10):
                    raise Exception("Leader did not broadcast FORCE_END")

        # Verify Worker receives it
        logging.info("Verifying Worker received FORCE_END...")
        if not wait_for_log("aggregator_products_service", "Received FORCE_END. Resetting ALL state...", timeout=30):
            raise Exception("Worker did not receive FORCE_END")
            
        logging.info("Server Failure Test PASSED!")
        
        # Wait for server to be revived
        time.sleep(10)

        # Restart client-1 because it likely died when server was killed
        logging.info("Restarting client-1...")
        run_command(["docker", "start", "client-1"], check=False)
        time.sleep(5)

        # 3. Test Case 2: Client Failure -> FORCE_END_CLIENT
        logging.info("Testing Client Failure -> FORCE_END_CLIENT")
        logging.info("Killing client-1...")
        run_command(["docker", "kill", "client-1"])
        
        # Verify Leader detects it
        # Note: monitor logs might be on any monitor depending on who is leader
        leader_found = False
        for mon in ["monitor_1", "monitor_2", "monitor_3"]:
            if wait_for_log(mon, "Client 1 died! Broadcasting FORCE_END_CLIENT...", timeout=5):
                leader_found = True
                break
        
        if not leader_found:
             # Give it a bit more time and check again
             if not wait_for_log("monitor_1", "Client 1 died! Broadcasting FORCE_END_CLIENT...", timeout=60):
                 raise Exception("Leader did not broadcast FORCE_END_CLIENT")

        # Verify Worker receives it
        logging.info("Verifying Worker received FORCE_END_CLIENT...")
        if not wait_for_log("aggregator_products_service", "Received FORCE_END_CLIENT for 1. Resetting client state...", timeout=30):
            raise Exception("Worker did not receive FORCE_END_CLIENT")

        logging.info("Client Failure Test PASSED!")
        logging.info("ALL TESTS PASSED!")

    except Exception as e:
        logging.error(f"TEST FAILED: {e}")
        sys.exit(1)
    finally:
        logging.info("Cleaning up...")
        # Optional: run_command(["make", "down"], check=False)

if __name__ == "__main__":
    main()
